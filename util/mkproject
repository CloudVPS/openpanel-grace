#!/bin/sh

SCRIPTFILE="$0"
DOMAIN=application
BUILDTYPE=app

TEST=`echo -n ""`
if [ -z "$TEST" ]; then
  ECHON="echo -n"
  NNL=""
else
  ECHON="echo"
  NNL="\c"
fi

# ===========================================================================
# Print an error and exit
# ===========================================================================
fail() {
  echo "ERR: $*" >&2
  exit 1
}

# ===========================================================================
# Extract a template out of this script file and perform some variable
# substitution on it, sending the result to stdout
# ===========================================================================
template() {
  if [ -z "$1" ]; then
    fail Not enough arguments for writetemplate.
  fi
  
  first="yes"
  
  cat "$SCRIPTFILE" \
  	| grep --after-context=99999 "^### TEMPLATE $1$" \
  	| tail +2 \
  	| grep --before-context=99999 "^### END TEMPLATE $1$" \
  	| grep -v "^### " \
  	| sed -e "s/%DOMAIN%/${DOMAIN}/g;s/%APPNAME%/${APPNAME}/g;s/%APPCNAME%/${APPCNAME}/g;s/%APPDOMAIN%/${APPDOMAIN}/g"
}

# ===========================================================================
# Print a question without a newline
# ===========================================================================
ask() {
  $ECHON "$*$NNL"
}

# ===========================================================================
# Write to a file inside the new project directory
# ===========================================================================
writefile() {
  cat > "$DIRNAME"/"$1" || fail "Error writing file $1"
  if [ ! -z "$2" ]; then
    chmod $2 "$DIRNAME"/"$1"
  fi
}

# ===========================================================================
# Create the project directory
# ===========================================================================
mkprojectdir() {
  mkdir "$DIRNAME" || fail "Could not create directory"
  echo "${APPDOMAIN}.${APPCNAME}" | writefile .appid
  echo "$APPNAME" | writefile .appname
  
  if [ "$BUILDTYPE" = "app" ]; then
    mkdir "${DIRNAME}/rsrc"
    template conf_xml | writefile rsrc/${APPDOMAIN}.${APPCNAME}.conf.xml
    template schema_xml | writefile rsrc/${APPDOMAIN}.${APPCNAME}.schema.xml
    template validator_xml | writefile rsrc/${APPDOMAIN}.${APPCNAME}.validator.xml
    template runoptions_xml | writefile rsrc/grace.runoptions.xml
    template makefile_app | writefile Makefile
  else
    template makefile_noapp | writefile Makefile
  fi
  
  template ${DOMAIN}_header_${BUILDTYPE} | writefile ${APPCNAME}.h
  template ${DOMAIN}_main_${BUILDTYPE} | writefile main.cpp
  template configure_in | writefile configure.in
  template configure | writefile configure 755
}
 
# ===========================================================================
# MAIN
# ===========================================================================

while [ ! -z "$1" ]; do
  case "$1" in
  	"-d")
  		DOMAIN=daemon
  		shift
  		;;
  	"--daemon")
  		DOMAIN=daemon
  		shift
  		;;
  	"-n")
  		BUILDTYPE=noapp
  		shift
  		;;
  	"--noapp")
  		BUILDTYPE=noapp
  		shift
  		;;
  	"--appname")
  		shift
  		APPNAME="$1"
  		shift
  		;;
  	"--domain")
  		shift
  		APPDOMAIN="$1"
  		shift
  		;;
  	*)
  		echo "Unknown option: $1" >&2
  		exit 1
  		;;
  esac
done

if [ -z "$APPDOMAIN" ]; then
  ask "Application domain [nl.madscience.unregistered.apps]: "
  read APPDOMAIN
  if [ -z "$APPDOMAIN" ]; then
    APPDOMAIN="nl.madscience.unregistered.apps"
  fi
  if [ -z "$APPNAME" ]; then
    ask "Application name: "
    read APPNAME
  fi
fi

APPCNAME=`echo "$APPNAME" | sed -e "s/ //g" | tr A-Z a-z`
DIRNAME="${APPDOMAIN}.${APPCNAME}"

mkprojectdir
exit 0

#############################################################################
### TEMPLATE application_header_app
#ifndef _%APPCNAME%_H
#define _%APPCNAME%_H 1
#include <grace/application.h>

//  -------------------------------------------------------------------------
/// Main application class.
//  -------------------------------------------------------------------------
class %APPCNAME%App : public application
{
public:
		 	 %APPCNAME%App (void) :
				application ("%APPDOMAIN%.%APPCNAME%")
			 {
			 }
			~%APPCNAME%App (void)
			 {
			 }

	int		 main (void);
};

#endif

### END TEMPLATE application_header_app

#############################################################################
### TEMPLATE daemon_header_app
#ifndef _%APPCNAME%_H
#define _%APPCNAME%_H 1
#include <grace/daemon.h>
#include <grace/configdb.h>

//  -------------------------------------------------------------------------
/// Implementation template for application config.
//  -------------------------------------------------------------------------
typedef configdb<class %APPCNAME%App> appconfig;

//  -------------------------------------------------------------------------
/// Main daemon class.
//  -------------------------------------------------------------------------
class %APPCNAME%App : public daemon
{
public:
		 				 %APPCNAME%App (void);
		 				~%APPCNAME%App (void);
		 	
	int					 main (void);
	
protected:
	bool				 confLog (config::action act, keypath &path,
								  const value &nval, const value &oval);

	appconfig			 conf;
};

#endif
### END TEMPLATE daemon_header_app

#############################################################################
### TEMPLATE application_main_app
#include "%APPCNAME%.h"

$appobject(%APPCNAME%App);

// ==========================================================================
// METHOD %APPCNAME%App::main
// ==========================================================================
int %APPCNAME%App::main (void)
{
	return 0;
}
### END TEMPLATE application_main_app

#############################################################################
### TEMPLATE daemon_main_app
#include "%APPCNAME%.h"

$appobject (%APPCNAME%App);

// ==========================================================================
// CONSTRUCTOR %APPCNAME%App
// ==========================================================================
%APPCNAME%App::%APPCNAME%App (void)
	: daemon ("%APPDOMAIN%.%APPCNAME%"),
	  conf (this)
{
}

// ==========================================================================
// DESTRUCTOR %APPCNAME%App
// ==========================================================================
%APPCNAME%App::~%APPCNAME%App (void)
{
}

// ==========================================================================
// METHOD %APPCNAME%App::main
// ==========================================================================
int %APPCNAME%App::main (void)
{
	string conferr; ///< Error return from configuration class.
	
	// Add watcher value for event log. System will daemonize after
	// configuration was validated.
	conf.addwatcher ("system/eventlog", &%APPCNAME%App::confLog);
	
	// Load will fail if watchers did not valiate.
	if (! conf.load ("%APPDOMAIN%.%APPCNAME%", conferr))
	{
		ferr.writeln ("%% Error loading configuration: %s" %format (conferr));
		return 1;
	}
	
	daemonize ();
	log::write (log::info, "main", "Started");
	value ev;
	
	while (true)
	{
		ev = waitevent ();
		if (ev.type() == "shutdown") break;
	}

	stoplog();
	return 0;
}

// ==========================================================================
// METHOD %APPCNAME%App::confLog
// ==========================================================================
bool %APPCNAME%App::confLog (config::action act, keypath &kp,
							  const value &nval, const value &oval)
{
	string tstr;
	
	switch (act)
	{
		case config::isvalid:
			// Check if the path for the event log exists.
			tstr = strutil::makepath (nval.sval());
			if (! tstr.strlen()) return true;
			if (! fs.exists (tstr))
			{
				ferr.writeln ("%% Log path %s does not exist" %format (tstr));
				return false;
			}
			return true;
			
		case config::create:
			// Set the event log target and daemonize.
			fout.writeln ("%% Event log: %s\n" %format (nval));
			addlogtarget (log::file, nval.sval(), 0xff, 1024*1024);
			return true;
	}
	
	return false;
}
### END TEMPLATE daemon_main_app

#############################################################################
#############################################################################

#############################################################################
### TEMPLATE application_header_noapp
#ifndef _%APPCNAME%_H
#define _%APPCNAME%_H 1
#include <grace/application.h>

//  -------------------------------------------------------------------------
/// Main application class.
//  -------------------------------------------------------------------------
class %APPCNAME%App : public application
{
public:
		 	 %APPCNAME%App (void) :
				application ("%APPDOMAIN%.%APPCNAME%")
			 {
			 	opt = $("-h", $("long", "--help"));
			 }
			~%APPCNAME%App (void)
			 {
			 }

	int		 main (void);
};

#endif

### END TEMPLATE application_header_noapp

#############################################################################
### TEMPLATE daemon_header_noapp
#ifndef _%APPCNAME%_H
#define _%APPCNAME%_H 1
#include <grace/daemon.h>
#include <grace/configdb.h>

//  -------------------------------------------------------------------------
/// Implementation template for application config.
//  -------------------------------------------------------------------------
typedef configdb<class %APPCNAME%App> appconfig;

//  -------------------------------------------------------------------------
/// Main daemon class.
//  -------------------------------------------------------------------------
class %APPCNAME%App : public daemon
{
public:
		 				 %APPCNAME%App (void);
		 				~%APPCNAME%App (void);
		 	
	int					 main (void);
	
protected:
	bool				 confLog (config::action act, keypath &path,
								  const value &nval, const value &oval);

	appconfig			 conf;
};

#endif
### END TEMPLATE daemon_header_noapp

#############################################################################
### TEMPLATE application_main_noapp
#include "%APPCNAME%.h"

$appobject(%APPCNAME%App);

// ==========================================================================
// METHOD %APPCNAME%App::main
// ==========================================================================
int %APPCNAME%App::main (void)
{
	return 0;
}
### END TEMPLATE application_main_noapp

#############################################################################
### TEMPLATE daemon_main_noapp
#include "%APPCNAME%.h"

$appobject (%APPCNAME%App);

// ==========================================================================
// CONSTRUCTOR %APPCNAME%App
// ==========================================================================
%APPCNAME%App::%APPCNAME%App (void)
	: daemon ("%APPDOMAIN%.%APPCNAME%"),
	  conf (this)
{
	opt = $("-h", $("long", "--help"));
}

// ==========================================================================
// DESTRUCTOR %APPCNAME%App
// ==========================================================================
%APPCNAME%App::~%APPCNAME%App (void)
{
}

// ==========================================================================
// METHOD %APPCNAME%App::main
// ==========================================================================
int %APPCNAME%App::main (void)
{
	string conferr; ///< Error return from configuration class.
	
	// Add watcher value for event log. System will daemonize after
	// configuration was validated.
	conf.addwatcher ("system/eventlog", &%APPCNAME%App::confLog);
	
	// Load will fail if watchers did not valiate.
	if (! conf.load ("%APPDOMAIN%.%APPCNAME%", conferr))
	{
		ferr.writeln ("%% Error loading configuration: %s" %format (conferr));
		return 1;
	}
	
	daemonize ();
	log::write (log::info, "main", "Started");
	value ev;
	
	while (true)
	{
		ev = waitevent ();
		if (ev.type() == "shutdown") break;
	}

	stoplog();
	return 0;
}

// ==========================================================================
// METHOD %APPCNAME%App::confLog
// ==========================================================================
bool %APPCNAME%App::confLog (config::action act, keypath &kp,
							  const value &nval, const value &oval)
{
	string tstr;
	
	switch (act)
	{
		case config::isvalid:
			// Check if the path for the event log exists.
			tstr = strutil::makepath (nval.sval());
			if (! tstr.strlen()) return true;
			if (! fs.exists (tstr))
			{
				ferr.writeln ("%% Log path %s does not exist" %format (tstr));
				return false;
			}
			return true;
			
		case config::create:
			// Set the event log target and daemonize.
			fout.writeln ("%% Event log: %s\n" %format (nval));
			addlogtarget (log::file, nval.sval(), 0xff, 1024*1024);
			return true;
	}
	
	return false;
}
### END TEMPLATE daemon_main_noapp

#############################################################################
### TEMPLATE conf_xml
<?xml version="1.0" encoding="utf-8"?>
<%APPDOMAIN%.%APPCNAME%.conf>
  <system>
    <eventlog>event.log</eventlog>
  </system>
</%APPDOMAIN%.%APPCNAME%.conf>
### END TEMPLATE conf_xml

#############################################################################
### TEMPLATE schema_xml
<?xml version="1.0" encoding="utf-8"?>
<xml.schema>
  <xml.class name="%APPDOMAIN%.%APPCNAME%.conf">
    <xml.type>dict</xml.type>
    <xml.proplist>
      <xml.member class="system" id="system"/>
    </xml.proplist>
  </xml.class>
  <xml.class name="system">
    <xml.type>dict</xml.type>
    <xml.proplist>
      <xml.member class="eventlog" id="eventlog"/>
    </xml.proplist>
  </xml.class>
  <xml.class name="eventlog">
    <xml.type>string</xml.type>
  </xml.class>
</xml.schema>
### END TEMPLATE schema_xml

#############################################################################
### TEMPLATE validator_xml
<?xml version="1.0" encoding="utf-8"?>
<grace.validator>
  <datarule id="root">
    <match.mandatory>
      <mandatory type="child" key="system"/>
    </match.mandatory>
    <match.child>
      <and>
        <match.id>system</match.id>
        <match.rule>system</match.rule>
      </and>
    </match.child>
  </datarule>
  
  <datarule id="system">
    <match.mandatory>
      <mandatory type="child" key="eventlog"/>
    </match.mandatory>
    <match.child>
      <match.id>eventlog</match.id>
    </match.child>
  </datarule>

</grace.validator>
### END TEMPLATE validator_xml

#############################################################################
### TEMPLATE runoptions_xml
<?xml version="1.0" encoding="utf-8"?>
<grace.runoptions>
  <grace.option id="-h">
    <grace.long>--help</grace.long>
  </grace.option>
  <grace.option id="--help">
    <grace.argc>0</grace.argc>
  </grace.option>
</grace.runoptions>
__END__
### END TEMPLATE runoptions_xml

#############################################################################
#############################################################################

#############################################################################
### TEMPLATE makefile_app
include makeinclude

OBJ	= main.o

all: %APPNAME%.exe
	mkapp %APPNAME%

%APPNAME%.exe: $(OBJ)
	$(LD) $(LDFLAGS) -o %APPNAME%.exe $(OBJ) $(LIBS)

clean:
	rm -f *.o *.exe
	rm -rf %APPNAME%.app
	rm -f %APPNAME%
	
allclean: clean
	rm -f makeinclude configure.paths platform.h

makeinclude:
	@echo please run ./configure
	@false

SUFFIXES: .cpp .o
.cpp.o:
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $<
### END TEMPLATE makefile_app

#############################################################################
### TEMPLATE makefile_noapp
include makeinclude

OBJ	= main.o

all: %APPNAME%

%APPNAME%: $(OBJ)
	$(LD) $(LDFLAGS) -o %APPNAME% $(OBJ) $(LIBS)

clean:
	rm -f *.o
	rm -f %APPNAME%

allclean: clean
	rm -f makeinclude configure.paths platform.h

makeinclude:
	@echo please run ./configure
	@false

SUFFIXES: .cpp .o
.cpp.o:
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $<
### END TEMPLATE makefile_noapp

#############################################################################
### TEMPLATE configure_in
cxx
grace
pthread
libsocket
libdl
libcrypt
### END TEMPLATE configure_in

#############################################################################
### TEMPLATE configure
#!/bin/sh
# ===========================================================================
# Configure script generated by tina (revision 0a7e6538920b+)
# ===========================================================================

# ---------------------------------------------------------------------------
# Solaris' /bin/sh uses a braindead builtin echo, circumvent
# ---------------------------------------------------------------------------
TEST=`echo -n ""`
if [ -z "$TEST" ]; then
  ECHON="echo -n"
  NNL=""
else
  ECHON="echo"
  NNL="\c"
fi

# ---------------------------------------------------------------------------
# Useful functions for command line argument parsing
# ---------------------------------------------------------------------------
usage ()
{
  S=`echo "$0" | sed -e "s/./ /g"`
  cat << EOF
Usage: $0 [--quiet]             Quiet mode [-q]
       $S [--prefix p]          Set root install-prefix
       $S [--exec-prefix p]     Set executable install-prefix
       $S [--lib-prefix p]      Set library install-prefix
       $S [--conf-prefix p]     Set configuration install-prefix
       $S [--include-prefix p]  Set include-files install-prefix
EOF
  exit 1
}
QUIET=0

# Checks for an option that is defined as --foo=bar. Returns 1 if so, or
# 0 if not. Caller can use this to shift in cases of "--foo bar".
parseopt() {
  withvalue=`echo "$1" | sed -e "s/.*=.*//"`
  if [ ! -z "$withvalue" ]; then
    return 0
  fi
  return 1
}

# Part two of the "--foo bar" eq "--foo=bar" trick: Use sed to strip the
# --foo= off the second variation. In either case we'll end up with "bar".
parsearg() {
	echo "$2" | sed -e "s/--${1}=//"
}

# Determine whether we're logged in as root.
isroot() {
	uid=`id | sed -e "s/^uid=//;s/ .*//;s/(.*//"`
	if [ "$uid" = "0" ]; then
	  return 0
	fi
	return 1
}

# Combine two paths.
makepath() {
	echo "${1}${2}" | sed -e "s@//@/@g;s@/\./@/.@g"
}

# ---------------------------------------------------------------------------
# Set up sensible defaults for the installation paths
# ---------------------------------------------------------------------------
if isroot; then
  if [ -d /sw ]; then
    INOPT_INSTALLROOT="/sw/"
  elif [ -d /usr/freeware ]; then
    INOPT_INSTALLROOT="/usr/freeware/"
  else
    INOPT_INSTALLROOT="/usr/local/"
  fi
else
  if [ -d "$HOME/.lib" ]; then
    INOPT_INSTALLROOT="$HOME/."
  elif [ -d "$HOME/Library/Preferences" ]; then
    INOPT_INSTALLROOT="$HOME/"
    
  else
    INOPT_INSTALLROOT="$HOME/"
  fi
fi

INOPT_INCLUDEPATH="include"
INOPT_BINPATH="bin"
INOPT_CONFPATH="etc/conf"
if [ ! -d "${INOPT_INSTALLROOT}${INOPT_CONFPATH}" ]; then
  if [ -d "${INOPT_INSTALLROOT}conf" ]; then
    INOPT_CONFPATH="conf"
  elif [ -d "${INOPT_INSTALLROOT}Library/Preferences" ]; then
    INOPT_CONFPATH="Library/Preferences"
  elif [ -d "${HOME}/Library/Preferences" ]; then
    CONFIG_CONFPATH="${HOME}/Library/Preferences"
  fi
fi

INOPT_LIBPATH="lib"
QUIET=0

# ---------------------------------------------------------------------------
# Parse the command line arguments
# ---------------------------------------------------------------------------
MOREOPTS="yes"
while [ ! -z "$MOREOPTS" ]; do
	case "$1" in
		-h)
			usage
			;;
		--help)
			usage
			;;
		-q)
			QUIET=1
			;;
		--prefix*)
			if parseopt "$1" "$2"; then shift; fi
			CONFIG_INSTALLROOT=`parsearg prefix "$1"`
			CONFIG_INSTALLROOT=`echo "${CONFIG_INSTALLROOT}/" | sed -e "s@//@@g"`
			CONFIG_BINPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_BINPATH"`
			CONFIG_LIBPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_LIBPATH"`
			CONFIG_CONFPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_CONFPATH"`
			;;
		--exec-prefix*)
			if parseopt "$1" "$2"; then shift; fi
			CONFIG_BINPATH=`parsearg exec-prefix "$1"`
			;;
		--lib-prefix*)
			if parseopt "$1" "$2"; then shift; fi
			CONFIG_LIBPATH=`parsearg lib-prefix "$1"`
			;;
		--conf-prefix*)
			if parseopt "$1" "$2"; then shift; fi
			CONFIG_CONFPATH=`parsearg conf-prefix "$1"`
			;;
		--include-prefix*)
			if parseopt "$1" "$2"; then shift; fi
			CONFIG_INCLUDEPATH=`parsearg include-prefix "$1"`
			;;
		--quiet)
			QUIET=1
			;;
		--)
			MOREOPTS=""
			;;
		--*)
			arg=`echo "$1" | cut -f1 -d=`
			echo "Unknown option: $arg" >&2
			exit 1
			;;
		*)
			MOREOPTS=""
			;;
	esac
	if [ ! -z "$MOREOPTS" ]; then shift; fi
done

# ---------------------------------------------------------------------------
# Merge values from command line to the actual defaults
# ---------------------------------------------------------------------------
if [ -z "$CONFIG_INSTALLROOT" ]; then
	CONFIG_INSTALLROOT="$INOPT_INSTALLROOT"
fi

if [ -z "$CONFIG_BINPATH" ]; then
  CONFIG_BINPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_BINPATH"`
fi

if [ -z "$CONFIG_LIBPATH" ]; then
	CONFIG_LIBPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_LIBPATH"`
fi

if [ -z "$CONFIG_CONFPATH" ]; then
	CONFIG_CONFPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_CONFPATH"`
fi

if [ -z "$CONFIG_INCLUDEPATH" ]; then
	CONFIG_INCLUDEPATH=`makepath "$CONFIG_INSTALLROOT" "$INOPT_INCLUDEPATH"`
fi

# ---------------------------------------------------------------------------
# Create the configure.paths file
# ---------------------------------------------------------------------------
cat > configure.paths << _EOF_
CONFIG_INSTALLROOT="${CONFIG_INSTALLROOT}"
CONFIG_BINPATH="${CONFIG_BINPATH}"
CONFIG_LIBPATH="${CONFIG_LIBPATH}"
CONFIG_CONFPATH="${CONFIG_CONFPATH}"
CONFIG_INCLUDEPATH="${CONFIG_INCLUDEPATH}"
_EOF_

# Display paths if our pie-hole is not closed administratively.
if [ $QUIET = 0 ]; then cat configure.paths; fi

# ---------------------------------------------------------------------------
# Provide a bunch of useful tools to our snippets
# ---------------------------------------------------------------------------
saypending ()
{
  if [ $QUIET = 1 ]; then
    PENDING=$1
  else
    $ECHON "$1: $NNL"
  fi
}

saypass ()
{
  if [ $QUIET = 1 ]; then
    : # nothing
  else
    echo "$1"
  fi
}

sayfail ()
{
  if [ $QUIET = 1 ]; then
    echo "$PENDING: $1" >&2
    exit 1
  else
    echo "$1"
    exit 1
  fi
}

sayfailsoft ()
{
  if [ $QUIET = 1 ]; then
    echo "$PENDING: $1" >&2
  else
    echo "$1"
  fi
}

echowarn ()
{
	if [ $QUIET = 1 ]; then
	  :
	else
	  echo "$1"
	fi
}
# ---------------------------------------------------------------------------
# Figure out if there's a Vendorware C++ compiler on board
# ---------------------------------------------------------------------------

saypending "looking for c++ compiler"
CXX=`which CC 2>/dev/null`

if [ -f "$CXX" ]; then
  actually_gcc=`$CXX -v 2>&1 | grep gcc | sed -e "s/^gcc/Y/"`

  cat >conftest.cpp <<_eof_
#include <stdio.h>
int main(int argc, char *argv[]) {
  printf ("hello, nurse\n");
}
_eof_

  $CXX -o conftest.bin conftest.cpp >/dev/null 2>&1 || actually_gcc="YES"
  rm -f conftest.cpp conftest.bin >/dev/null 2>&1
  if [ ! -z "$actually_gcc" ]; then
    CXX=""
  fi
fi

DYNEXT="so"

if [ -f "$CXX" ]; then
  saypass "$CXX"
  CXXFLAGS="-n32 -O"
  SHARED="-shared"
  LD="$CXX"
  LDSHARED="$CXX -shared $LDFLAGS"
  LDFLAGS=""
else
  CXX=`which g++`
  if [ -f "$CXX" ]; then
    saypass "$CXX"
    CXXFLAGS=${CXXFLAGS}
    un=`uname`
    if [ "$un" = "Darwin" ]; then
      SHARED="-fno-common"
      LDSHARED="$CXX $LDFLAGS -dynamiclib -undefined dynamic_lookup"
      DYNEXT="dylib"
    else
      SHARED="-shared -fPIC"
      LDSHARED="\$(COMPILER) -shared \$(LDFLAGS)"
    fi
    LD="$CXX"
    LDFLAGS=""
  else
    sayfail "fail"
    CXX=""
    exit 1;
  fi
fi

COMPILER=${CXX}
COMPILERFLAGS=${CXXFLAGS}
# ---------------------------------------------------------------------------
# Figure out path to Grace include
# ---------------------------------------------------------------------------

saypending "looking for grace include"
for loc in /sw/include /usr/local/include /usr/X11R6/include /usr/include $HOME/include ../../include $HOME/.include; do
  if [ -f "$loc/grace/str.h" ]; then
    GRACEINC="$loc"
  fi
done
if [ -z "$GRACEINC" ]; then
  sayfail "failed"
  exit 1
fi
saypass "$GRACEINC"

# ---------------------------------------------------------------------------
# Figure out path to Grace library
# ---------------------------------------------------------------------------

saypending "looking for grace library"
for loc in /sw/lib /usr/lib32 /usr/lib64 /usr/lib /usr/local/lib /usr/freeware/lib $HOME/lib $HOME/.lib ../../lib; do
  if [ -f "$loc/libgrace.$DYNEXT" ]; then
    LIBGRACE="-L$loc -lgrace"
  fi
done
if [ -z "$LIBGRACE" ]; then
  sayfail "failed"
  exit 1
fi
saypass "$LIBGRACE"

# ---------------------------------------------------------------------------
# Check for libpthread functionality
# ---------------------------------------------------------------------------

cat >conftest.c <<EOF
#include <pthread.h>
#include <stdio.h>

int main (int argc, char *argv[])
{
	pthread_attr_t attr;
	pthread_mutexattr_t mattr;
	
	pthread_attr_init (&attr);
	pthread_mutexattr_init (&mattr);
	return 1;
}
EOF

saypending "checking for pthread support"
if $COMPILER $COMPILERFLAGS -o conftest conftest.c >>configure.log 2>&1; then
  LIBPTHREAD=""
  saypass "yes"
else
  if $COMPILER $COMPILERFLAGS -o conftest conftest.c -lpthread >>configure.log 2>&1; then
    LIBPTHREAD="-lpthread"
	saypass "-lpthread"
  elif $COMPILER $COMPILERFLAGS -o conftest conftest.c -lc_r >>configure.log 2>&1; then
    LIBPTHREAD="-lc_r"
    saypass "-lc_r"
  else
    sayfail "no - This application needs a working pthreads implementation."
  fi
fi

saypending "checking for ctime_r"
cat > conftest.c << EOF
#include <time.h>
int main (int argc, char *argv[])
{
	char buf[256];
	char *result;
	time_t ti;
	result = ctime_r (&ti, buf);
	return 0;
}
EOF
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >>configure.log 2>&1; then
  saypass "time.h"
else
  cat > conftest.c << EOF
#define _POSIX_C_SOURCE 199506L
#define _POSIX_PTHREAD_SEMANTICS 1
#define _XOPEN_SOURCE 1
#define __EXTENSIONS__ 1
#include <pthread.h>
#include <time.h>
int main (int argc, char *argv[])
{
	char buf[256];
	char *result;
	time_t ti;
	result = ctime_r (&ti, buf);
	return 0;
}
EOF
  if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >>configure.log 2>&1; then
    saypass "time.h with solaris twist"
    CTIME_R_INCLUDE="#include <pthread.h>"
    CTIME_R_PTHREAD_DEFINE="#define _POSIX_PTHREAD_SEMANTICS 1"
    CTIME_R_XOPEN_DEFINE="#define _XOPEN_SOURCE 1"
    CTIME_R_XPG_DEFINE="#define __EXTENSIONS__ 1"
    CTIME_R_DEFINE="#define _POSIX_C_SOURCE 199506L"
  else
    sayfail "screwed"
  fi
fi

saypending "checking for pthread_rwlock_t"
cat > conftest.c << EOF
#include <pthread.h>
int main (int argc, char *argv[])
{
	pthread_rwlock_t *rwlock;
	pthread_rwlock_trywrlock (rwlock);
	return 0;
}
EOF
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >>configure.log 2>&1; then
  saypass "yes"
  PTHREAD_HAVE_RWLOCK="#define PTHREAD_HAVE_RWLOCK 1"
  saypending "checking for pthread_rwlock_timedwrlock"
  cat > conftest.c << EOF
#include <pthread.h>
#include <time.h>
int main (int argc, char *argv[])
{
	pthread_rwlock_t *rwlock;
	struct timespec ts;
	pthread_rwlock_timedwrlock (rwlock, &ts);
	return 0;
}
EOF
  if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >> configure.log 2>&1; then
    saypass "yes"
    PTHREAD_HAVE_TIMEDLOCK="#define PTHREAD_HAVE_TIMEDLOCK 1"
  else
    saypass "no"
    PTHREAD_HAVE_TIMEDLOCK=""
  fi
else
  saypass "no"
  PTHREAD_HAVE_RWLOCK=""
  PTHREAD_HAVE_TIMEDLOCK=""
fi


rm -f conftest conftest.o conftest.c
# ---------------------------------------------------------------------------
# Figure out whether we need libsocket
# ---------------------------------------------------------------------------

cat >conftest.c <<EOF
#include <sys/types.h>
#include <sys/socket.h>

int main (int argc, char *argv[])
{
    int test = socket(PF_INET, SOCK_STREAM, 0);
    return 1;
}
EOF

saypending "checking whether socket needs -lsocket"
if $COMPILER $COMPILERFLAGS -o conftest conftest.c >>configure.log 2>&1; then
  LIBSOCKET=""
  saypass "no"
else
  LIBSOCKET="-lsocket"
  saypass "yes"
fi

rm -f conftest.c conftest

# ---------------------------------------------------------------------------
# Figure out whether we need libnsl
# ---------------------------------------------------------------------------

cat >conftest.c <<EOF
#include <netdb.h>

int main (int argc, char *argv[])
{
	struct hostent *h = gethostbyname("localhost");
    return 1;
}
EOF

saypending "checking whether gethostbyname needs -lnsl"
if $COMPILER $COMPILERFLAGS -o conftest conftest.c >>configure.log 2>&1; then
  LIBNSL=""
  saypass "no"
else
  LIBNSL="-lnsl"
  saypass "yes"
fi

rm -f conftest.c conftest

# ---------------------------------------------------------------------------
# Figure out whether socklen_t is defined
# ---------------------------------------------------------------------------

cat >conftest.c <<EOF
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
	socklen_t len = (socklen_t) 4;
	return 1;
}
EOF

saypending "checking whether socklen_t needs to be defined"
if $COMPILER $COMPILERFLAGS -o conftest conftest.c >> configure.log 2>&1; then
  SOCKLEN_TYPEDEF=""
  saypass "no"
else
  SOCKLEN_TYPEDEF="typedef int socklen_t;"
  saypass "yes"
fi

rm -f conftest conftest.c


# ---------------------------------------------------------------------------
# Figure out whether we need libdl
# ---------------------------------------------------------------------------

cat >conftest.cpp <<EOF
#include <dlfcn.h>
int main (int argc, char *argv[])
{
   void *test = dlopen ("conftest.so",RTLD_LAZY);
   return 1;
}
EOF

saypending "checking whether dlopen needs -ldl"
if $CXX $CXXFLAGS -o conftest conftest.cpp >>configure.log 2>&1; then
  LIBDL=""
  saypass "no"
else
  LIBDL="-ldl"
  saypass "yes"
fi

cat >conftest.cpp <<EOF
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/types.h>
extern "C" int find_me (void)
{
	return 1;
}

typedef int (*fptr)(void);

int main (int argc, char *argv[])
{

	void *test = dlopen (NULL,RTLD_LAZY);
	fptr func = (fptr) dlsym (test, "find_me");
	if (! func) return 1;
	int res = (*func)();
	if (res == 1) return 0;
	return 1;
}
EOF

saypending "checking need for export-dynamic"
if $CXX $CXXFLAGS -c -o conftest.o conftest.cpp >> configure.log 2>&1; then
  :
else
  sayfail "error"
fi
if $LD $LDFLAGS -o conftest conftest.o $LIBDL >>configure.log 2>&1; then
  if ./conftest; then
    LIBDL_LDFLAGS=""
    saypass "no"
  elif $LD $LDFLAGS -Wl,--export-dynamic -o conftest conftest.o $LIBDL >> configure.log 2>&1; then
	if ./conftest; then
	  LIBDL_LDFLAGS="-Wl,--export-dynamic"
	  saypass "yes"
	else
	  saypass "no"
	  echowarn "warning: no suitable method found to resolve internal symbols of the "
	  echowarn "         running process, library-defined optional initialization "
	  echowarn "         hooks may not work as advertised"
	fi
  else
    saypass "no"
	echowarn "warning: no suitable method found to resolve internal symbols of the "
	echowarn "         running process, library-defined optional initialization "
	echowarn "         hooks may not work as advertised"
  fi
else
  sayfail "error - libdl linking not working out"
fi

rm -f conftest.cpp conftest


# ---------------------------------------------------------------------------
# Figure out whether we need libcrypt
# ---------------------------------------------------------------------------

cat >conftest.c <<EOF
#include <crypt.h>
int main (int argc, char *argv[])
{
  char *test = crypt("abcdefg","aB");
  return 1;
}
EOF

saypending "checking where crypt() hides"
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >> configure.log 2>&1; then
  CRYPTH="#include <crypt.h>"
  saypass "crypt.h"
else
cat >conftest.c <<EOF
#include <unistd.h>
int main (int argc, char *argv[])
{
   char *test = crypt("abcdefg","aB");
   return 1;
}
EOF
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >>configure.log 2>&1; then
  saypass "unistd.h"
  CRYPTDEFINE=""
else
cat >conftest.c <<EOF
#define _XOPEN_SOURCE
#include <unistd.h>
int main (int argc, char *argv[])
{
   char *test = crypt("abcdefg","aB");
   return 1;
}
EOF
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >>configure.log 2>&1; then
  saypass "unistd.h"
  CRYPTDEFINE="#define _XOPEN_SOURCE"
else
  cat > conftest.c <<EOF
#define _XOPEN_SOURCE 5
#include <unistd.h>
int main (int argc, char *argv[])
{
    char *test = crypt("abcdefg","aB");
    return 1;
}
EOF
if $COMPILER $COMPILERFLAGS -o conftest.o -c conftest.c >> configure.log 2>&1; then
  saypass "unistd.h (evil netbsd)"
  CRYPTDEFINE="#define _XOPEN_SOURCE 5"
else
  sayfail "failed"
  exit 1
fi
fi
fi
fi
saypending "checking whether crypt needs -lcrypt"
if $COMPILER $COMPILERFLAGS -o conftest conftest.o >>configure.log 2>&1; then
  LIBCRYPT=""
  saypass "no"
else
  LIBCRYPT="-lcrypt"
  saypass "yes"
fi

rm -f conftest.c conftest.o conftest
# ---------------------------------------------------------------------------
# Create the makeinclude file
# ---------------------------------------------------------------------------

saypending "creating makeinclude"

DATE=`date`

cat >makeinclude <<EOF
# Makeinclude generated by configure: $DATE

COMPILER = $COMPILER
COMPILERFLAGS = $COMPILERFLAGS
CXX = $CXX
CXXFLAGS = $CXXFLAGS
DYNEXT = $DYNEXT
INCLUDES = -I$GRACEINC
LD = $LD
LDFLAGS = $LDFLAGS $LIBDL_LDFLAGS
LDL = $LIBDL
LDSHARED = $LDSHARED
LGRACE = $LIBGRACE
LIBS = $LIBGRACE $LIBPTHREAD $LIBSOCKET $LIBNSL $LIBDL $LIBCRYPT
LPTHREAD = $LIBPTHREAD
LSOCKET = $LIBSOCKET $LIBNSL
SHARED = $SHARED
EOF

saypass "done"
# ---------------------------------------------------------------------------
# Create the platform.h file
# ---------------------------------------------------------------------------

saypending "creating platform.h"

cat >platform.h <<EOF
#ifndef _PLATFORM_H
#define _PLATFORM_H
$CTIME_R_DEFINE
$CTIME_R_PTHREAD_DEFINE
$CTIME_R_XOPEN_DEFINE
$CTIME_R_XPG_DEFINE
$CTIME_R_INCLUDE
$PTHREAD_HAVE_RWLOCK
$PTHREAD_HAVE_TIMEDLOCK

$SOCKLEN_TYPEDEF
$CRYPTH
$CRYPTDEFINE
#endif
EOF

saypass "done"
if [ -f configure.log ]; then rm -f configure.log; fi

### END TEMPLATE configure
