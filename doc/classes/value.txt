The value class                                   GRACE Library Documentation

1.INTRODUCTION

The value class represents generic storage for data of any type, stored
either directly or as child-values indexed by an array index or a string
key. Besides indexed child data, a value object can also carry a list of
named attributes, normally represented as string data.


2.DATA TYPES

Data contained within a value object or one of its children is natively
stored as one of the following types:

	Type		Sz	Method	Ctypes		Description
	char		1	ival()	char		Signed 8-bit integer
	uchar		1	uval()	uchar		Unsigned 8-bit integer
	short		2	ival()	short		Signed 16-bit integer
	ushort		2	uval()	short		Unsigned 16-bit integer
	int			4	ival()	int			Signed 32-bit integer
	unsigned	4	uval()	unsigned	Unsigned 32-bit integer
	long		8	lval()	longlong	Signed 64-bit integer
	ulong		8	ulval()	ulonglong	Unsigned 64-bit integer
	bool		1	ival()	bool		True/false boolean
	double		x	dval()	double		Floating point number
	string		x	sval()	string		Variable size string
	ipaddr		4	ipval()	unsigned	Unsigned 32-bit IPv4 address
	array		x	-		-			A numbered array of value objects
	dict		x	-		-			A keyed associative array of values
	date		4	-		-			A timestamp
	void		0	-		-			An undetermined value

The value class relies heavily on C++ operator overloading features, which
can be treacherous if it leads to unexpected behavior. The value class has
casting operators for the types listed above. The following examples may
be of help here:

	value v;
	v = 16; // v.type() == "int"
	if (v > 15) printf ("v>15\n"); // should work
	if (v == "16") printf ("v=='16'\n"); // as should this
	
	v = "foobar" // v.type() == "string"
	v = (unsigned int) 42; // v.type() == "unsigned"
	
One extra casting method called cval() can be used to implicitly cast a
value object as a C string:

	v = "world";
	printf ("Hello, %s.\n", v.cval());


3.ARRAY HANDLING

You can access child nodes of a value through the [] operators, just like
with a C array. Array members will cast as a reference to a value object and
they will be const if the original was const. Members are implicitly created
when they do not exist yet and the original was not const. Const values will
return themselves if asked for a child that does not exist.

  - You can use value::exists(key) to check for the existence of a node.
  - You can use value::newval() to add an unnamed node to the end of an
    array.
  - You can access the last value of an array by using the index [-1]
  - You can remove an indexed array member with value::rmindex (pos)
  - You can remove a named child value with value::rmval (key)
  - Child members with a key index are still also an indexed array member
  - A child value's key can be accessed through value::label() or through
    value::name(). The latter returns a C string, the first a statstring.


4.ATTRIBUTE HANDLING

Attributes are a special kind of child value. Although they are internally
represented as value objects, their possibilities necessarily differ from
real children because attributes cannot have children of their own and are
generally expressed as strings.

You can get the string value of an attribute using the value::operator()
method. This returns a constant (immutable) string. To set an attribute,
use the slightly longer value::setattrib (key, stringvalue) method.

If you need to access or manipulate attributes more in bulk, it is possible
to access the attributes directly as a value object using the
value::attributes() call. If you are investigating an object in 'const'
context, you can use value::haveattributes() to verify that the object
has attributes at all. Checking for a specific attribute then is a matter
of invoking value::exists() on the key, like:

	void foo (const value &inputValue)
    {
		if (! inputValue.haveattributes()) return;
		if (! inputValue.attributes().exists ("attribname")) return;
		doSomethingWithAttrib (inputValue.attributes()["attribname"]);
	}

Always keep in mind that attributes should have no children. Once you
get them as a value object through attributes(), the class definition
does not prevent you from creating, or trying to access grandchildren,
but the storage methods have no way of encoding the result.


5.BUGS AND PITFALLS

  - It can be very tempting to try to change an attribute by stating:

      myValue("attrib") = "value";

    This will generate a compiler error because the operator() method
    only returns const string object references which you cannot assign
    to a new value.


6.OPERATORS AND CASTS

  - assignment operators
  
    (value &) ((value) = (const value &))
    (value &) ((value) = (value *))
    (value &) ((value) = (bool))
    (value &) ((value) = (long long))
    (value &) ((value) = (time_t))
    (value &) ((value) = (unsigned long long))
    (value &) ((value) = (const char *))
    (value &) ((value) = (const string &))
    (value &) ((value) = (string *))
    (value &) ((value) = (int))
    (value &) ((value) = (unsigned int))
    (value &) ((value) = (double))

  - equality checks
  
    (bool) ((value) == != < <= >= > (const value &))
    (bool) ((value) == !=           (const char *))
    (bool) ((value) == != < <= >= > (int))
    (bool) ((value) == != < <= >= > (unsigned int))
    (bool) ((value) == != < <= >= > (long long))
    (bool) ((value) == != < <= >= > (unsigned long long))
    (bool) ((value) == != < <= >= > (bool))
    
  - array combination
  
    (value &) ((value) << (const value &))
    (value &) ((value) << (value *))
    
  - array concatenation
  
    (value &) ((value) += (const string &))
    (value &) ((value) += (value &))
    
  - typecasts
  
    (bool)				 = (value)
    (long long) 		 = (value)
    (unsigned long long) = (value)
    (int)				 = (value)
    (unsigned int)		 = (value)
    (const string &)	 = (value)
    (const char *)		 = (value)
    (double)			 = (value)


7.SEE ALSO
  - statstring
  - string
  - xmlschema
